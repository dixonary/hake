{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}

module Main where

import Graphics.Gloss hiding (text, Point)
import qualified Graphics.Gloss as G (text)

import Graphics.Gloss.Interface.IO.Interact (Event (..), Key (..) )
import qualified Graphics.Gloss.Interface.IO.Interact as K (KeyState (..))
import Data.Fixed (mod')
import qualified Graphics.Gloss.Data.Color as Color
import Grid
import Config
import Prelude hiding (Either, Left, Right)

-- Useful base data types

data World = World {
    state      :: State,
    titleFlash :: Float,
    dir        :: Direction,
    tickTimer  :: Float,
    snake      :: [Point],
    pellets    :: [Point],
    tickPeriod :: Float
}

data State = Title | Play | GameOver
    deriving (Eq, Show)

data Direction = Up | Down | Left | Right
    deriving (Eq, Show)

-- Default world structure
defWorld       = World {
    state      = Title,
    titleFlash = 0,
    dir        = Up,
    tickTimer  = tickPeriod defWorld,
    snake      = replicate 5 midGrid,
    pellets    = [],
    tickPeriod = 0.3
}


main :: IO ()
main = play
    (InWindow "Snake &&&" gameSize gamePos) -- Window information
    bgColor                                 -- Background color
    60                                      -- Max FPS
    defWorld                                -- Initial "world"
    render                                  -- Rendering function
    handleInput                             -- Input handler
    update                                  -- Update handler



render :: World -> Picture
render world@World{..} = pictures $
        renderGrid snake pellets       -- Always render the grid
    :
    case state of
        Title ->
            if titleFlash `mod'` 1.5 < 0.9 then
                [translate (-290) (-350) $ text 30 4 "PRESS W/A/S/D TO START"]
            else
                []
        Play -> []
        GameOver ->
            if titleFlash `mod'` 1.5 < 0.9 then
                [translate (-200) (0)   $ color mdColor $ text 50 4 "GAME OVER",
                 translate (-200) (-80) $ color mdColor $ text 30 4 "SPACE TO RESTART"]
            else
                []


handleInput :: Event -> World -> World
handleInput (EventKey (Char c) K.Down _ _) world@World{..}  =
    let world' = world { dir =
        case c of
            'w' -> Up
            's' -> Down
            'a' -> Left
            'd' -> Right
            _   -> dir
        }
    in if state == Title then world' { state = Play }
                         else world'
handleInput e world = world


update :: Float -> World -> World
update time world@World{..} = case state of
    Title -> world {
        titleFlash = titleFlash + time
        }
    Play -> let
            newTickTime = tickTimer + time
            newWorld = world {tickTimer = newTickTime `mod'` tickPeriod}
        in
        if newTickTime > tickPeriod then tick newWorld else newWorld

    GameOver -> world {
        titleFlash = titleFlash + time
        }


tick :: World -> World
tick world@World{..} = let

    updateSnake :: [Point] -> Maybe Point -> [Point] -> Maybe [Point]
    updateSnake []     _           new = Just new
    updateSnake (c:cs) Nothing     new =
        let next    = nextPos c
            newCell = getCell emptyGrid next

        in case newCell of
                Nothing -> Nothing
                Just _  -> updateSnake cs (Just c) (new ++ [next])
    updateSnake (c:cs) (Just prev) new = updateSnake cs (Just c) (new ++ [prev])

    -- Find the next head position.
    nextPos :: Point -> Point
    nextPos (px,py) = traceIt $ case dir of
        Up    -> (px  ,py-1)
        Down  -> (px  ,py+1)
        Left  -> (px-1,  py)
        Right -> (px+1,  py)

    newSnake = updateSnake snake Nothing []
    in
        case newSnake of
            Nothing -> world { state = GameOver }
            Just ns -> world { snake = ns }





-- Helper function for rendering nicer text.
-- Yes, this does render a LOT of text items.
text :: Float -> Float -> String -> Picture
text size boldness str =
    scale (size / 100) (size/100) $
    pictures [translate x y $ G.text str | x <- [0,0.5..boldness], y <- [0,0.5..boldness] ]

